import cvxpy as cp
import numpy as np
from tqdm import tqdm
import matplotlib.pyplot as plt
import itertools
from gurobipy import Model, GRB, quicksum
import torch
from torch.optim import LBFGS
import dccp 
import casadi as ca

def fluid_value(T, N, lam, y0):
    b = 2* N * np.sqrt(lam)  
    
    u = ca.MX.sym('u', T)
    y = ca.MX.sym('y', T+1)

    # objective
    epsilon = .1
    J = 0
    for t in range(T):
        J += N**2*u[t] + y[t] + epsilon*u[t]**2
    J = (J+y[T])/T

    # constraints list
    g = []
    # initial condition
    g.append(y[0] - y0)
    # dynamics
    for t in range(T):
        g.append(y[t+1] - (y[t] + lam - u[t]*y[t]))
        g.append(u[t] - (np.sqrt(lam)/N)) 

    # pack into NLP
    w   = ca.vertcat(u, y)
    nlp = {'x': w, 'f': J, 'g': ca.vertcat(*g)}
    opts = {'ipopt.print_level': 0, 'print_time': 0}
    solver = ca.nlpsol('S', 'ipopt', nlp, opts)

    # bounds
    lbg = [0]*(T+1)         # dynamics = 0, init = 0
    ubg = [0]*(T+1)
    lbx = [0]*T + [0]*(T+1)  # u >= 0, y >= 0
    ubx = [1]*T + [1e6]*(T+1)

    # solve
    res = solver(lbx=lbx, ubx=ubx, lbg=lbg, ubg=ubg)
    w_opt = res['x'].full().flatten()
    u_opt = w_opt[:T]
    y_opt = w_opt[T:]
    return float(res['f']), u_opt, y_opt

def fluid_value(T, N, lam, y0):
    device = "cpu"       # or "cuda"
    dtype  = torch.float64
    b     = 2*N*(lam**0.5)

    def forward_y(u, y0):
        """Return y_0,…,y_{T-1} generated by the control sequence u."""
        ys = [torch.as_tensor(y0, dtype=dtype, device=device)]
        for ut in u:
            ys.append((1.0 - ut) * ys[-1] + lam)
        return torch.stack(ys[:-1])          # length T

    def objective(u):
        """Scalar objective J(u)."""
        y = forward_y(u, y0)
        return torch.sum(N**2 * u + y - b)
    # --- decision variables as unconstrained parameters -----------
    # To keep u in [0,1] we parameterise u = sigmoid(w)
    w = torch.zeros(T, dtype=dtype, device=device, requires_grad=True)
    def closure():
        optimizer.zero_grad()
        u = torch.sigmoid(w)
        loss = objective(u)
        loss.backward()
        return loss

    optimizer = LBFGS([w], lr=1.0, max_iter=500, tolerance_grad=1e-12)
    optimizer.step(closure)
    u_opt = torch.sigmoid(w).detach()
    y_path = forward_y(u_opt, y0).detach()
    
    return objective(u_opt).item(), u_opt.cpu().numpy(), y_path.cpu().numpy()

def fluid_value(T, N, lam, y0):
    b     = 2*N*(lam**0.5)
    y_max = y0 + T*lam

    m = Model()
    m.Params.NonConvex = 2

    # variables
    u = m.addVars(T, lb=0.0, ub=1.0, name="u")
    y = m.addVars(T+1, lb=0.0, ub=y_max, name="y")

    # initial state
    m.addConstr(y[0] == y0)

    # dynamics: y[t+1] == y[t] + lam - u[t]*y[t]
    for t in range(T):
        m.addQConstr(
            y[t+1] == y[t] + lam - u[t]*y[t],
            name=f"dynamics_{t}"
        )

    # objective: minimize sum(N^2 u_t + y_t) - T b
    m.setObjective(
        quicksum(N**2 * u[t] + y[t] for t in range(T))
        - T*b,
        GRB.MINIMIZE
    )

    m.optimize()

    u_opt = [u[t].X for t in range(T)]
    y_opt = [y[t].X for t in range(T+1)]
    return m.ObjVal, u_opt, y_opt

def fluid_value(T, N, lam, y0):
    b     = 2*N*(lam**0.5)
    y_max = y0 + T*lam

    m = Model()

    # vars
    u = m.addVars(T, lb=0.0, ub=1.0, name="u")
    y = m.addVars(T+1, lb=0.0, ub=y_max, name="y")
    v = m.addVars(T, lb=0.0, ub=y_max, name="v")  # = u_t * y_t

    # initial state
    m.addConstr(y[0] == y0)

    # linearized dynamics
    for t in range(T):
        m.addConstr(y[t+1] == y[t] + lam - v[t])

    # McCormick envelopes
    for t in range(T):
        m.addConstr(v[t] <= y[t])
        m.addConstr(v[t] <= y_max * u[t])
        m.addConstr(v[t] >= y[t] - y_max * (1 - u[t]))
        # v[t] >= 0 already enforced by lb=0

    # objective
    m.setObjective(
        quicksum(N**2 * u[t] + y[t] for t in range(T)) - T*b + y[T],
        GRB.MINIMIZE
    )

    m.optimize()

    u_opt = [u[t].X for t in range(T)]
    y_opt = [y[t].X for t in range(T+1)]
    return m.ObjVal, u_opt, y_opt



def fluid_value(T, N, lam, y0):
    """
    Solve the fluid model optimization problem.
    
    Parameters:
    - T: Time horizon
    - N: Scaling factor for control input
    - lam: Rate of change
    - y0: Initial state
    
    Returns:
    - u: Optimal control input
    """
    b = 2* N * np.sqrt(lam)  
    y_max   = y0 + T*lam 
    u = cp.Variable(T)
    y = cp.Variable(T+1)
    v = cp.Variable(T)  # Auxiliary variable for McCormick envelope

    # Objective function
    obj = cp.Minimize(cp.sum(N**2 * u + y[:-1]) - T*b)

    # Constraints
    cons = [y[0] == y0,
            0 <= u, u <= 1,
            0 <= y,              # y ≥ 0
            0 <= v] 
            #u == np.sqrt(lam)/N]              # first McCormick inequality

    # Dynamics with v instead of u*y
    for t in range(T):
        cons += [y[t+1] == y[t] + lam - v[t]]

    # Remaining McCormick envelope constraints
    cons += [
        v <= y[:-1],                         # v ≤ y_t
        v <= y_max * u,                      # v ≤ y_max u_t
        v >= y[:-1] - y_max * (1 - u)        # v ≥ y_t - y_max(1-u_t)
    ]

    prob = cp.Problem(obj, cons)
    prob.solve()   # LP; any LP/QP solver works

    return prob.value, u.value, y.value

def fluid_value(T, N, lam, y0):
    """
    Solve the fluid model optimization problem.
    
    Parameters:
    - T: Time horizon
    - N: Scaling factor for control input
    - lam: Rate of change
    - y0: Initial state
    
    Returns:
    - u: Optimal control input
    """
    b = 2* N * np.sqrt(lam)  
    y_max   = y0 + T*lam 
    u = cp.Variable(T)
    y = cp.Variable(T+1)
    
    # Objective function
    obj = cp.Minimize(cp.sum(N**2 * u + y[:-1]) - T*b)

    # Constraints
    cons = [y[0] == y0,
            0 <= u, u <= 1,
            0 <= y] 
           
    # Dynamics with v instead of u*y
    for t in range(T):
        cons += [y[t+1] == y[t] + lam - y[t]*u[t]]

    prob = cp.Problem(obj, cons)
    prob.solve(method='dccp', ccp_times=10, max_iter=500, verbose=True)

    return prob.value, u.value, y.value

def fluid_array(T, N, lam_values, upper_bound_capacity):
    #Solve the deterministic version of the multi-secretary problem for all periods in approx_periods and all capacities
    capacities = np.arange(0, upper_bound_capacity + 1, 1)
    val_deterministic = np.zeros((len(lam_values), capacities.shape[0]))
    solution_deterministic = np.zeros((len(lam_values), capacities.shape[0], T))
    for indx, lam in tqdm(enumerate(lam_values)):
        for indx_cap, x in tqdm(enumerate(capacities)):
            val_deterministic[indx, indx_cap] = fluid_value(T, N, lam, x)[0]
            solution_deterministic[indx, indx_cap, :] = fluid_value(T, N, lam, x)[1]

    return val_deterministic, solution_deterministic

def fluid_average_network(rewards, arrival_rates, service_rates, capacity):
    """
    Parameters
    ----------
    rewards        : 1-D ndarray (length m)
    arrival_rates  : 1-D ndarray (length m)
    service_rates  : 1-D ndarray (length m)
    capacity       : scalar (total number of servers / processors / etc.)

    Returns
    -------
    result         : optimal long-run average reward (fluid heuristic)
    """
    order = np.argsort(-(rewards * service_rates))   # minus sign ⇒ descending
    rewards        = rewards[order]
    arrival_rates  = arrival_rates[order]
    service_rates  = service_rates[order]

    n_types   = rewards.size
    x_temp    = np.zeros(n_types)

    # effective offered load per class
    restriction = arrival_rates / service_rates

    cumsum  = np.cumsum(restriction)
    feasible_mask = cumsum <= capacity

    if not feasible_mask.any():                 # nothing fits
        x_temp[0] = capacity
    else:
        i_max = feasible_mask.sum() - 1         # last class that fully fits
        x_temp[:i_max + 1] = restriction[:i_max + 1]

        # allocate the leftover capacity: 
        if i_max + 1 < n_types:
            x_temp[i_max + 1] = capacity - x_temp[:i_max + 1].sum()

    return np.dot(rewards*service_rates, x_temp)

def fluid_average_network_array(rewards, arrival_rates, service_rates, capacities):
    """
    Parameters
    ----------
    rewards        : 1-D ndarray (length m)
    arrival_rates  : 1-D ndarray (length m)
    service_rates  : 1-D ndarray (length m)
    capacities     : 1-D ndarray (length n)

    Returns
    -------
    result         : optimal long-run average reward (fluid heuristic)
    """
    results = np.zeros(capacities.shape[0])
    for i, capacity in enumerate(capacities):
        results[i] = fluid_average_network(rewards, arrival_rates, service_rates, capacity)
    return results

def fluid_value_network(T, rewards, arrival_rates, service_rates, capacity, average_cost, x0):
    """
    Solve the fluid model optimization problem for a network.

    Parameters:
    - T: Time horizon
    - rewards: Rewards for each class
    - arrival_rates: Arrival rates for each class
    - service_rates: Service rates for each class
    - capacity: Total capacity of the network
    - average_cost: Average cost of the system

    Returns:
    - u: Optimal control input
    - value: Optimal value of the problem
    """
    K = len(rewards)
    a = cp.Variable((K, T))
    x = cp.Variable((K, T+1))
    
    arrival_reward = cp.multiply(arrival_rates , rewards)
    # Objective function
    objective = cp.Maximize(cp.sum(arrival_reward @ a) - cp.multiply(T , average_cost))


    constraints = []

    # (i) initial condition
    constraints += [x[:, 0] == x0]

    # (ii) dynamics  x_{t+1} = x_t + λ a_t − μ x_t   for every t
    for t in range(T):
        constraints += [
            x[:, t+1] == x[:, t] + cp.multiply(arrival_rates , a[:, t]) - cp.multiply(service_rates,x[:, t])
        ]

    # (iii) capacity   Σ_i x_i(t) ≤ q
    constraints += [
        cp.sum(x[:, t]) <= capacity for t in range(1, T + 1)            # you can include t = 0 as well if needed
    ]

    # (iv) bounds
    constraints += [
        x >= 0,
        a >= 0,
        a <= 1
    ]

    prob = cp.Problem(objective, constraints)
    prob.solve()   # LP; any LP/QP solver works

    return prob.value, a.value

def fluid_value_network_array(T, rewards, arrival_rates, service_rates, capacity, average_cost, initial_states):
    """
    Solve the fluid model optimization problem for a network for multiple capacities.

    Parameters:
    - T: Time horizon
    - rewards: Rewards for each class
    - arrival_rates: Arrival rates for each class
    - service_rates: Service rates for each class
    - capacities: Array of total capacities of the network
    - average_cost: Average cost of the system
    - Initial states: Initial state

    Returns:
    - val_deterministic: Optimal values for each capacity
    - solution_deterministic: Optimal control inputs for each capacity
    """
    val_deterministic = np.zeros(initial_states.shape[0])
    solution_deterministic = np.zeros((initial_states.shape[0], rewards.shape[0], T))
    
    for indx, x0 in tqdm(enumerate(initial_states)):
        val_deterministic[indx], solution_deterministic[indx] = fluid_value_network(T, rewards, arrival_rates, service_rates, capacity, average_cost, x0)

    return val_deterministic, solution_deterministic

